{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conia Wire Wire provides an autowiring object creator that utilizes PHP's reflection capabilities to automatically resolve constructor arguments recursively. It additionally comes with classes that assist in resolving arguments of callables such as functions, methods, closures or class constructors. It can be combined with a PSR-11 dependency injection container. Installation composer require conia/wire How to create objects To create an object without knowing its classes' constructor arguments, simply create a Creator instance and pass the fully qualified class name to its resolver method: use Conia\\Wire\\Wire; $creator = Wire::creator(); // creates a `Creator` instance $model = $creator->create(Model::class); For a complete introduction and fully working examples, see The Creator How to resolve arguments To get a list of instantiated arguments for a callable or a constructor you can use one of the resolvers. Here you can see simplified example on how to use the CallableResolver : function readValue(Value $value): string { return $value->str; } $resolver = Wire::callableResolver(); $args = $resolver->resolve('readValue'); readValue(...$args); More information on callable and constructor argument resolvers together with fully functioning examples can be found here: Argument resolvers Other features To be able to resolve generally unresolvable constructor or callable argument types like literals ( string , int , etc.), interfaces, or abstract classes, Wire 's classes can be combined with a PSR-11 compatible container implementation. See PSR-11 Containers . If an object needs additional method calls after instantiation to be properly initialized you can use the Call class attribute. To override or change the default behaviour of the resolvers, or handle literal values, you can annotate parameters of callables and constructors with the Inject Attribute .","title":"Introduction"},{"location":"#conia-wire","text":"Wire provides an autowiring object creator that utilizes PHP's reflection capabilities to automatically resolve constructor arguments recursively. It additionally comes with classes that assist in resolving arguments of callables such as functions, methods, closures or class constructors. It can be combined with a PSR-11 dependency injection container.","title":"Conia Wire"},{"location":"#installation","text":"composer require conia/wire","title":"Installation"},{"location":"#how-to-create-objects","text":"To create an object without knowing its classes' constructor arguments, simply create a Creator instance and pass the fully qualified class name to its resolver method: use Conia\\Wire\\Wire; $creator = Wire::creator(); // creates a `Creator` instance $model = $creator->create(Model::class); For a complete introduction and fully working examples, see The Creator","title":"How to create objects"},{"location":"#how-to-resolve-arguments","text":"To get a list of instantiated arguments for a callable or a constructor you can use one of the resolvers. Here you can see simplified example on how to use the CallableResolver : function readValue(Value $value): string { return $value->str; } $resolver = Wire::callableResolver(); $args = $resolver->resolve('readValue'); readValue(...$args); More information on callable and constructor argument resolvers together with fully functioning examples can be found here: Argument resolvers","title":"How to resolve arguments"},{"location":"#other-features","text":"To be able to resolve generally unresolvable constructor or callable argument types like literals ( string , int , etc.), interfaces, or abstract classes, Wire 's classes can be combined with a PSR-11 compatible container implementation. See PSR-11 Containers . If an object needs additional method calls after instantiation to be properly initialized you can use the Call class attribute. To override or change the default behaviour of the resolvers, or handle literal values, you can annotate parameters of callables and constructors with the Inject Attribute .","title":"Other features"},{"location":"call-attribute/","text":"The Call Attribute Occasionally, especially when a dependency is optional, there may be additional steps required to initialize an object beyond simply invoking the constructor. When you encounter this situation, you can use the Call attribute to annotate a class and specify which method should be called after the object is created using the constructor. Without annotation Given the following simplified example: class Value { public function get(): string { return 'Value'; } } class Model { public ?Value $value = null; public function setValue(Value $value): void { $this->value = $value; } } Without Wire 's help, you need to create a Model instance, and then call the setValue method, passing a Value object as an argument. $model = new Model(); $model->setValue(new Value()); assert($model->value->get() === 'Value'); Annotated with the Call attribute If you create an object using the creator and the class is annotated with one or more Call attributes, autowiring will automatically invoke any method specified in the attribute(s) as the first argument. use Conia\\Wire\\Call; use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } #[Call('setValue')] class Model { public ?Value $value = null; public function setValue(Value $value): void { $this->value = $value; } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model->value->get() === 'Autowired Value'); Multiple method calls As mentioned before, you can annotate a class with multiple Call attributes. The methods are invoked in the same order in which the attributes are defined. use Conia\\Wire\\Call; use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } #[Call('setValue'), Call('setAnotherValue')] class Model { public ?Value $value = null; public ?Value $anotherValue = null; public function setValue(Value $value): void { $this->value = $value; } public function setAnotherValue(Value $value): void { $this->anotherValue = $value; } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model->value->get() === 'Autowired Value'); assert($model->anotherValue->get() === 'Autowired Value'); Provide arguments If an argument for a method cannot be autowired, such as literal values like strings or numbers, you can pass them as named arguments to the Call attribute. This serves as a hint for the autowiring mechanism. The names must match the parameter names of the callable: use Conia\\Wire\\Call; use Conia\\Wire\\Wire; #[Call('setString', str: 'Coming from attribute')] class Model { public string $str = ''; public function setString(string $str): void { $this->str = $str; } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model->str === 'Coming from attribute');","title":"The Call Attribute"},{"location":"call-attribute/#the-call-attribute","text":"Occasionally, especially when a dependency is optional, there may be additional steps required to initialize an object beyond simply invoking the constructor. When you encounter this situation, you can use the Call attribute to annotate a class and specify which method should be called after the object is created using the constructor.","title":"The Call Attribute"},{"location":"call-attribute/#without-annotation","text":"Given the following simplified example: class Value { public function get(): string { return 'Value'; } } class Model { public ?Value $value = null; public function setValue(Value $value): void { $this->value = $value; } } Without Wire 's help, you need to create a Model instance, and then call the setValue method, passing a Value object as an argument. $model = new Model(); $model->setValue(new Value()); assert($model->value->get() === 'Value');","title":"Without annotation"},{"location":"call-attribute/#annotated-with-the-call-attribute","text":"If you create an object using the creator and the class is annotated with one or more Call attributes, autowiring will automatically invoke any method specified in the attribute(s) as the first argument. use Conia\\Wire\\Call; use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } #[Call('setValue')] class Model { public ?Value $value = null; public function setValue(Value $value): void { $this->value = $value; } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model->value->get() === 'Autowired Value');","title":"Annotated with the Call attribute"},{"location":"call-attribute/#multiple-method-calls","text":"As mentioned before, you can annotate a class with multiple Call attributes. The methods are invoked in the same order in which the attributes are defined. use Conia\\Wire\\Call; use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } #[Call('setValue'), Call('setAnotherValue')] class Model { public ?Value $value = null; public ?Value $anotherValue = null; public function setValue(Value $value): void { $this->value = $value; } public function setAnotherValue(Value $value): void { $this->anotherValue = $value; } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model->value->get() === 'Autowired Value'); assert($model->anotherValue->get() === 'Autowired Value');","title":"Multiple method calls"},{"location":"call-attribute/#provide-arguments","text":"If an argument for a method cannot be autowired, such as literal values like strings or numbers, you can pass them as named arguments to the Call attribute. This serves as a hint for the autowiring mechanism. The names must match the parameter names of the callable: use Conia\\Wire\\Call; use Conia\\Wire\\Wire; #[Call('setString', str: 'Coming from attribute')] class Model { public string $str = ''; public function setString(string $str): void { $this->str = $str; } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model->str === 'Coming from attribute');","title":"Provide arguments"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. This project adheres to Semantic Versioning . 0.3.0 - 2024-01-18 Breaking Changes Changed the Inject attribute so that is is now annotated to parameters instead of functions or methods. Added Add Type::Callback . The optional injectCallback parameter to Creator::create . The optional injectCallback parameter to CallableResolver::resolve . The optional injectCallback parameter to ConstructorResolver::resolve . Creator now returns the container entry of the requested class if it exists. This way it supports instantiating interfaces if they are registered in the container. 0.2.0 - 2024-01-05 Add predefined types. Added The predefinedTypes parameter to Creator::create . The predefinedTypes parameter to CallableResolver::resolve . The predefinedTypes parameter to ConstructorResolver::resolve . 0.1.0 - 2023-11-11 Initial release. Added The Wire factory, which produces Creator , CallableResolver and ContstructorResolver instances. The Inject attribute. The Call attribute. The ability to be combined with PSR-11 containers.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. This project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#030-2024-01-18","text":"","title":"0.3.0 - 2024-01-18"},{"location":"changelog/#breaking-changes","text":"Changed the Inject attribute so that is is now annotated to parameters instead of functions or methods.","title":"Breaking Changes"},{"location":"changelog/#added","text":"Add Type::Callback . The optional injectCallback parameter to Creator::create . The optional injectCallback parameter to CallableResolver::resolve . The optional injectCallback parameter to ConstructorResolver::resolve . Creator now returns the container entry of the requested class if it exists. This way it supports instantiating interfaces if they are registered in the container.","title":"Added"},{"location":"changelog/#_1","text":"","title":""},{"location":"changelog/#020-2024-01-05","text":"Add predefined types.","title":"0.2.0 - 2024-01-05"},{"location":"changelog/#added_1","text":"The predefinedTypes parameter to Creator::create . The predefinedTypes parameter to CallableResolver::resolve . The predefinedTypes parameter to ConstructorResolver::resolve .","title":"Added"},{"location":"changelog/#010-2023-11-11","text":"Initial release.","title":"0.1.0 - 2023-11-11"},{"location":"changelog/#added_2","text":"The Wire factory, which produces Creator , CallableResolver and ContstructorResolver instances. The Inject attribute. The Call attribute. The ability to be combined with PSR-11 containers.","title":"Added"},{"location":"container/","text":"The Role of PSR-11 Containers Autowiring is effective when all the parameters in the constructor of a class and its dependencies consist of objects of classes that do not require literals like strings, arrays, or numbers as constructor arguments. Dependencies that require objects to be instances of abstract types, such as interfaces or abstract classes, are not supported either. These are obviously huge limitations. But there is a solution: The creator and all resolvers can be initialized with a container that is compatible with PSR-11. It is used internally to resolve arguments that cannot be determined otherwise. Entries in the container are prioritized. This means that autowiring will only be used to inject dependencies if the type of a parameter is not already registered in the container. Do not refuse to use the container Only in the simplest cases is a container not necessary. If only one of your dependencies requires a literal argument, you are doomed. Most of the time it is a good idea to combine Wire with a container implementation. Be warned about the simplified examples In the examples, we utilize a very basic container mock, which is also used in Wire 's test suite. More often than not, in the following code snippets, we store initialized objects in the container mock. We do this only to be able to show easy to understand code. Of course, you should utilize a fully fledged container implementation and leverage its functionality to retrieve values that cannot be resolved by Wire . The Problem In the following example, the resolver cannot autowire the Value class because it cannot determine the value for the constructor parameter $value , which is of type string : use Conia\\Wire\\Exception\\WireException; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } } class Model { public function __construct(protected Value $value) { } } $creator = Wire::creator(); try { $creator->create(Model::class); } catch (WireException $e) { $message = $e->getMessage(); } finally { assert(str_contains($message, 'Parameter not resolvable')); } Solving the problem By adding the parameter type that was causing the issue to a container implementation that is compatible with PSR-11, and then initializing the creator with that container, the problem no longer exists. As shown in the code block below: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } class Model { public function __construct(protected Value $value) { } public function get(): string { return $this->value->get(); } } $container = new Container(); $container->add(Value::class, new Value('Model value')); $creator = Wire::creator($container); $model = $creator->create(Model::class); assert($model->get() === 'Model value'); Abstract types If there are abstract types like interfaces or abstract classes expected in the constructor of a class or its dependencies you will also need to work with a container: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; interface ValueInterface { public function get(): string; } class Value implements ValueInterface { public function get(): string { return 'From Value'; } } class Model { public function __construct(public ValueInterface $value) { } } $container = new Container(); $container->add(ValueInterface::class, new Value()); $creator = Wire::creator($container); $model = $creator->create(Model::class); assert($model->value->get() === 'From Value'); Resolvers and containers Since the resolvers are the guts and the bones of the creator they work the same way: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } function readValue(Value $value): string { return $value->get(); } $container = new Container(); $container->add(Value::class, new Value('Model value')); $resolver = Wire::callableResolver($container); $args = $resolver->resolve('readValue'); assert(readValue(...$args) === 'Model value'); Note If don't want to use the Wire factory to create a resolver you have to pass the container via the Creator that is needed for all resolver constructors. More information: Creating the creator without factory and Creating resolvers without factory","title":"PSR-11 Containers"},{"location":"container/#the-role-of-psr-11-containers","text":"Autowiring is effective when all the parameters in the constructor of a class and its dependencies consist of objects of classes that do not require literals like strings, arrays, or numbers as constructor arguments. Dependencies that require objects to be instances of abstract types, such as interfaces or abstract classes, are not supported either. These are obviously huge limitations. But there is a solution: The creator and all resolvers can be initialized with a container that is compatible with PSR-11. It is used internally to resolve arguments that cannot be determined otherwise. Entries in the container are prioritized. This means that autowiring will only be used to inject dependencies if the type of a parameter is not already registered in the container. Do not refuse to use the container Only in the simplest cases is a container not necessary. If only one of your dependencies requires a literal argument, you are doomed. Most of the time it is a good idea to combine Wire with a container implementation. Be warned about the simplified examples In the examples, we utilize a very basic container mock, which is also used in Wire 's test suite. More often than not, in the following code snippets, we store initialized objects in the container mock. We do this only to be able to show easy to understand code. Of course, you should utilize a fully fledged container implementation and leverage its functionality to retrieve values that cannot be resolved by Wire .","title":"The Role of PSR-11 Containers"},{"location":"container/#the-problem","text":"In the following example, the resolver cannot autowire the Value class because it cannot determine the value for the constructor parameter $value , which is of type string : use Conia\\Wire\\Exception\\WireException; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } } class Model { public function __construct(protected Value $value) { } } $creator = Wire::creator(); try { $creator->create(Model::class); } catch (WireException $e) { $message = $e->getMessage(); } finally { assert(str_contains($message, 'Parameter not resolvable')); }","title":"The Problem"},{"location":"container/#solving-the-problem","text":"By adding the parameter type that was causing the issue to a container implementation that is compatible with PSR-11, and then initializing the creator with that container, the problem no longer exists. As shown in the code block below: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } class Model { public function __construct(protected Value $value) { } public function get(): string { return $this->value->get(); } } $container = new Container(); $container->add(Value::class, new Value('Model value')); $creator = Wire::creator($container); $model = $creator->create(Model::class); assert($model->get() === 'Model value');","title":"Solving the problem"},{"location":"container/#abstract-types","text":"If there are abstract types like interfaces or abstract classes expected in the constructor of a class or its dependencies you will also need to work with a container: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; interface ValueInterface { public function get(): string; } class Value implements ValueInterface { public function get(): string { return 'From Value'; } } class Model { public function __construct(public ValueInterface $value) { } } $container = new Container(); $container->add(ValueInterface::class, new Value()); $creator = Wire::creator($container); $model = $creator->create(Model::class); assert($model->value->get() === 'From Value');","title":"Abstract types"},{"location":"container/#resolvers-and-containers","text":"Since the resolvers are the guts and the bones of the creator they work the same way: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } function readValue(Value $value): string { return $value->get(); } $container = new Container(); $container->add(Value::class, new Value('Model value')); $resolver = Wire::callableResolver($container); $args = $resolver->resolve('readValue'); assert(readValue(...$args) === 'Model value'); Note If don't want to use the Wire factory to create a resolver you have to pass the container via the Creator that is needed for all resolver constructors. More information: Creating the creator without factory and Creating resolvers without factory","title":"Resolvers and containers"},{"location":"creator/","text":"The Object Creator Wire 's object Creator class helps you create instances of classes for which you don't have their constructor arguments at hand. It attempts to obtain or gather all the required values by analyzing the types of the constructor parameters of the class. Basic usage of the object creator use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class Model { public function __construct(protected Value $value) { } public function value(): string { return $this->value->get(); } } $creator = Wire::creator(); // creates a `Creator` instance $model = $creator->create(Model::class); assert($model instanceof Model); assert($model->value() === 'Autowired Value'); Behind the scenes, Wire will create both the Value and the Model objects. Since a Value object is required to initialize Model it is created beforehand and then passed to the constructor of Model . Value does not have constructor parameters and can therefore be instantiated safely. Technically, the creator uses reflection to determine the types of Model 's constructor parameters. If a parameter type is a class the creator will try to instantiate it by analyzing its constructor parameters as well. This process works recursively, continuously resolving arguments until they are all resolved, or until it encounters an unresolvable parameter. PSR-11 Containers When combined with a PSR-11 compatible dependency injection container, the creator can be assisted in resolving parameters that would otherwise be unresolvable. See PSR-11 Containers . Factory methods If a class uses a static factory method to create an instance, you can pass the name of the method to Creator::create : use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class Model { public function __construct( public readonly Value $value, public readonly string $str ) { } public static function createModel( Value $value, string $str = 'default string' ): self { return new self($value, $str); } } $creator = Wire::creator(); $model = $creator->create(Model::class, constructor: 'createModel'); assert($model instanceof Model); assert($model->value->get() === 'Autowired Value'); assert($model->str === 'default string'); Parameters with default values If a parameter has a default value and is otherwise unresolvable, the default value is used: use Conia\\Wire\\Wire; class Model { public function __construct(public string $str = 'default value') { } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model instanceof Model); assert($model->str === 'default value'); Assist the creator with arguments that are already available Predefined arguments If you already have some or all of the arguments available to you, you can pass them to the create method by using an associative array. Predefined arguments are matched by name. When the name of the parameter to be resolved is the same as a key in the associative array, the value of that key is passed as the argument. use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class Model { public function __construct( protected string $str, protected Value $value ) { } public function value(): string { return $this->value->get() . ' ' . $this->str; } } $creator = Wire::creator(); $model = $creator->create(Model::class, predefinedArgs: ['str' => 'and str']); assert($model instanceof Model); assert($model->value() === 'Autowired Value and str'); Predefined types These are very similar to predefined arguments. But instead of using a parameter's name to find a match in the associative array, it uses its type. Additionally, they are also used deeper down the object tree: use Conia\\Wire\\Wire; class DeepValue { public function __construct(public readonly string $value) { } } class Value { public function __construct(public readonly DeepValue $deep) { } public function get(): string { return 'Autowired Value'; } } class AnotherValue { public function __construct(public readonly string $str) { } } class Model { public function __construct( public readonly Value $value, public readonly AnotherValue $another, ) { } } $creator = Wire::creator(); $model = $creator->create( Model::class, predefinedTypes: [ AnotherValue::class => new AnotherValue('predefined value'), DeepValue::class => new DeepValue('deep value'), ] ); assert($model instanceof Model); assert($model->value->get() === 'Autowired Value'); assert($model->value->deep->value === 'deep value'); assert($model->another->str === 'predefined value'); You can also combine predefined types with the Inject attribute : use Conia\\Wire\\Inject; use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class AnotherValue { public function __construct(public readonly string $str) { } } class Model { public function __construct( public readonly Value $value, #[Inject('use-this-id')] public readonly AnotherValue $another, ) { } } $creator = Wire::creator(); $model = $creator->create( Model::class, predefinedTypes: ['use-this-id' => new AnotherValue('predefined value')] ); assert($model instanceof Model); assert($model->value->get() === 'Autowired Value'); assert($model->another->str === 'predefined value'); Creating the creator without the Wire factory Internally the Wire factory initializes the creator like shown here: use Conia\\Wire\\Creator; // A PSR-11 container implementation like // https://conia.dev/registry or https://php-di.org use Conia\\Wire\\Tests\\Fixtures\\Container; $container = new Container(); $creator = new Creator($container); // Or without container $creator = new Creator();","title":"The Creator"},{"location":"creator/#the-object-creator","text":"Wire 's object Creator class helps you create instances of classes for which you don't have their constructor arguments at hand. It attempts to obtain or gather all the required values by analyzing the types of the constructor parameters of the class.","title":"The Object Creator"},{"location":"creator/#basic-usage-of-the-object-creator","text":"use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class Model { public function __construct(protected Value $value) { } public function value(): string { return $this->value->get(); } } $creator = Wire::creator(); // creates a `Creator` instance $model = $creator->create(Model::class); assert($model instanceof Model); assert($model->value() === 'Autowired Value'); Behind the scenes, Wire will create both the Value and the Model objects. Since a Value object is required to initialize Model it is created beforehand and then passed to the constructor of Model . Value does not have constructor parameters and can therefore be instantiated safely. Technically, the creator uses reflection to determine the types of Model 's constructor parameters. If a parameter type is a class the creator will try to instantiate it by analyzing its constructor parameters as well. This process works recursively, continuously resolving arguments until they are all resolved, or until it encounters an unresolvable parameter. PSR-11 Containers When combined with a PSR-11 compatible dependency injection container, the creator can be assisted in resolving parameters that would otherwise be unresolvable. See PSR-11 Containers .","title":"Basic usage of the object creator"},{"location":"creator/#factory-methods","text":"If a class uses a static factory method to create an instance, you can pass the name of the method to Creator::create : use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class Model { public function __construct( public readonly Value $value, public readonly string $str ) { } public static function createModel( Value $value, string $str = 'default string' ): self { return new self($value, $str); } } $creator = Wire::creator(); $model = $creator->create(Model::class, constructor: 'createModel'); assert($model instanceof Model); assert($model->value->get() === 'Autowired Value'); assert($model->str === 'default string');","title":"Factory methods"},{"location":"creator/#parameters-with-default-values","text":"If a parameter has a default value and is otherwise unresolvable, the default value is used: use Conia\\Wire\\Wire; class Model { public function __construct(public string $str = 'default value') { } } $creator = Wire::creator(); $model = $creator->create(Model::class); assert($model instanceof Model); assert($model->str === 'default value');","title":"Parameters with default values"},{"location":"creator/#assist-the-creator-with-arguments-that-are-already-available","text":"","title":"Assist the creator with arguments that are already available"},{"location":"creator/#predefined-arguments","text":"If you already have some or all of the arguments available to you, you can pass them to the create method by using an associative array. Predefined arguments are matched by name. When the name of the parameter to be resolved is the same as a key in the associative array, the value of that key is passed as the argument. use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class Model { public function __construct( protected string $str, protected Value $value ) { } public function value(): string { return $this->value->get() . ' ' . $this->str; } } $creator = Wire::creator(); $model = $creator->create(Model::class, predefinedArgs: ['str' => 'and str']); assert($model instanceof Model); assert($model->value() === 'Autowired Value and str');","title":"Predefined arguments"},{"location":"creator/#predefined-types","text":"These are very similar to predefined arguments. But instead of using a parameter's name to find a match in the associative array, it uses its type. Additionally, they are also used deeper down the object tree: use Conia\\Wire\\Wire; class DeepValue { public function __construct(public readonly string $value) { } } class Value { public function __construct(public readonly DeepValue $deep) { } public function get(): string { return 'Autowired Value'; } } class AnotherValue { public function __construct(public readonly string $str) { } } class Model { public function __construct( public readonly Value $value, public readonly AnotherValue $another, ) { } } $creator = Wire::creator(); $model = $creator->create( Model::class, predefinedTypes: [ AnotherValue::class => new AnotherValue('predefined value'), DeepValue::class => new DeepValue('deep value'), ] ); assert($model instanceof Model); assert($model->value->get() === 'Autowired Value'); assert($model->value->deep->value === 'deep value'); assert($model->another->str === 'predefined value'); You can also combine predefined types with the Inject attribute : use Conia\\Wire\\Inject; use Conia\\Wire\\Wire; class Value { public function get(): string { return 'Autowired Value'; } } class AnotherValue { public function __construct(public readonly string $str) { } } class Model { public function __construct( public readonly Value $value, #[Inject('use-this-id')] public readonly AnotherValue $another, ) { } } $creator = Wire::creator(); $model = $creator->create( Model::class, predefinedTypes: ['use-this-id' => new AnotherValue('predefined value')] ); assert($model instanceof Model); assert($model->value->get() === 'Autowired Value'); assert($model->another->str === 'predefined value');","title":"Predefined types"},{"location":"creator/#creating-the-creator-without-the-wire-factory","text":"Internally the Wire factory initializes the creator like shown here: use Conia\\Wire\\Creator; // A PSR-11 container implementation like // https://conia.dev/registry or https://php-di.org use Conia\\Wire\\Tests\\Fixtures\\Container; $container = new Container(); $creator = new Creator($container); // Or without container $creator = new Creator();","title":"Creating the creator without the Wire factory"},{"location":"inject-attribute/","text":"The Inject Attribute By annotating function or method parameters with an Inject attribute, you can tell the resolvers and, consequently, the creator how to obtain arguments that cannot be resolved otherwise or to apply arguments that would not be used by default. This means that you can use it to override Wire 's default behavior, for example when you want to choose one of several alternatives or when there are literal arguments such as strings, numbers or arrays expected. Example Let's assume you have two different functions, each of which requires a Model object as input. But you want to ensure that one of the functions always receives a SubModel instance, which is a subclass of Model . The following example shows how to accomplish that: use Conia\\Wire\\Inject; use Conia\\Wire\\Wire; class Model { } class SubModel extends Model { } function expectsModel(Model $model): Model { return $model; } function alsoExpectsModel( #[Inject(SubModel::class)] Model $model ): Model { return $model; } $resolver = Wire::callableResolver(); // `expectsModel` is not annotated. An object of the base class is created $args = $resolver->resolve('expectsModel'); $result = expectsModel(...$args); assert($result instanceof Model); // `alsoExpectsModel` is annotated. An object of the sub class is created $args = $resolver->resolve('alsoExpectsModel'); $result = alsoExpectsModel(...$args); assert($result instanceof SubModel); You can control the behavior of the function (in this case, alsoExpectsModel ) by annotating the parameter it with an Inject attribute. If the parameter is not annotated, the resolver would create an object of the base class Model because the type of the parameter $model is Model . How to use Simply add the Inject attribute to a parameter of a callable or constructor that you want to control. You pass a mandatory argument with the value you want the callable's argument to have, or, if it's not a literal, with an identifier from which the value is derived ( see below for a detailed description ). The snippet below shows the relevant part of the example above: function alsoExpectsModel ( #[Inject ( SubModel :: class ) ] Model $model ): Model { ... The Inject instance The first parameter $value of the Inject constructor is required and of type mixed. The second parameter $type is optional and of type Conia\\Wire\\Type which is a enum. Both are availabe as public instance properties. Every additional argument is avalable via the meta property. use Conia\\Wire\\Inject; use Conia\\Wire\\Type; $inject = new Inject('value', Type::Literal, text: 'string', number: 13); assert($inject->value === 'value'); assert($inject->type === Type::Literal); assert($inject->meta['text'] === 'string'); assert($inject->meta['number'] === 13); $inject = new Inject('value', text: 'string', number: 13); assert($inject->value === 'value'); assert($inject->type === null); assert($inject->meta['text'] === 'string'); assert($inject->meta['number'] === 13); $inject = new Inject('value', null, 31, 73, 'text'); assert($inject->value === 'value'); assert($inject->type === null); assert($inject->meta === [31, 73, 'text']); Note In most cases, you will only work directly with an Inject instance if you use the Inject type Type::Callback . See below . How injected argument values are determined The resolvers behave differently depending on the type of value that you want to be injected. Warning The resolver does not check if a value which was obtained with the help of an Inject attribute matches the parameters type of the callable it should be applied to, so handle with care. Strings If the value is a string, like in the following example: #[Inject('container.id')] // or #[Inject(SubModel::class)] the resolver uses the following rules. If a container is available, see if it has an entry with and id matching the value of the string. If so, return it, if not continue with step 2. If the string is the full qualified name of an existing class, try to create it using the creator and return it. If not, continue with step 3. Return the string as-is. The literal rest All other types, like arrays, numbers, booleans or null values are passed to the callable or are returned by the resolver as they are, i. e. as unchanged literals. function withLiteralParams( #[Inject(['number' => 13, 'str' => 'value'])] array $arrayParam, #[Inject(73)] int $integerParam, #[Inject(13.37)] float $floatParam, #[Inject(true)] bool $booleanParam, #[Inject(null)] ?string $nullableParam, ) { ... Don't follow the rules If you want to bypass the string rules or be explicit about the values you inject, you can specifiy the type of the injected value. Additionally, with that feature, you can have control over how a value is generated. The inject type is passed as second argument to the Inject attribute und must be of the data type Conia\\Wire\\Type : // a valid array #[Inject('value', Conia\\Wire\\Type::Literal)] The available types are: Conia\\Wire\\Type::Literal Returns the value as is. #[Inject('a string value', Type::Literal)] public function myCallable(string $value): void Conia\\Wire\\Type::Entry Uses the value as id to fetch a value from the container . $container->add('container.entry.id', new Object()); public function myCallable( #[Inject('container.entry.id', Type::Entry)] Object $value ): void $container->add(\\Your\\Interface::class, new Object()); public function myCallable( #[Inject(\\Your\\Interface::class, Type::Entry)] \\Your\\Interface $value ): void Conia\\Wire\\Type::Create Must be a fully qualified class name which the creator attemtps to create. public function myCallable( #[Inject(SubModel::class, Type::Create)] Model $value ): void Conia\\Wire\\Type::Env The value is assumed to be the name an environment variable. It attempts to read the environment variable using PHP's internal function getenv and then returns its value. public function myCallable( #[Inject('PATH', Type::Env)] string|bool $value ): void { // $value has now the content of the environment variable PATH } Conia\\Wire\\Type::Callback All resolving methods, like Creator::create or CallableResolver::resolve , accept a callback function for the parameter $injectCallback that will be passed all Inject attributes of type Type::Callback . The returned value of the callback is then used for the annotated parameter. use Conia\\Wire\\Inject; use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Type; use Conia\\Wire\\Wire; class Value { public function __construct(public readonly string $str) { } } class Model { public function __construct( #[Inject(Value::class, Type::Callback, tag: 'tag2')] public readonly Value $value ) { } } $container = new Container(); $container->add(Value::class . 'tag1', new Value('Tagged with 1')); $container->add(Value::class . 'tag2', new Value('Tagged with 2')); $creator = Wire::creator($container); $model = $creator->create( Model::class, injectCallback: function (Inject $inject) use ($container): mixed { return $container->get($inject->value . $inject->meta['tag']); } ); assert($model instanceof Model); assert($model->value->str === 'Tagged with 2');","title":"The Inject Attribute"},{"location":"inject-attribute/#the-inject-attribute","text":"By annotating function or method parameters with an Inject attribute, you can tell the resolvers and, consequently, the creator how to obtain arguments that cannot be resolved otherwise or to apply arguments that would not be used by default. This means that you can use it to override Wire 's default behavior, for example when you want to choose one of several alternatives or when there are literal arguments such as strings, numbers or arrays expected.","title":"The Inject Attribute"},{"location":"inject-attribute/#example","text":"Let's assume you have two different functions, each of which requires a Model object as input. But you want to ensure that one of the functions always receives a SubModel instance, which is a subclass of Model . The following example shows how to accomplish that: use Conia\\Wire\\Inject; use Conia\\Wire\\Wire; class Model { } class SubModel extends Model { } function expectsModel(Model $model): Model { return $model; } function alsoExpectsModel( #[Inject(SubModel::class)] Model $model ): Model { return $model; } $resolver = Wire::callableResolver(); // `expectsModel` is not annotated. An object of the base class is created $args = $resolver->resolve('expectsModel'); $result = expectsModel(...$args); assert($result instanceof Model); // `alsoExpectsModel` is annotated. An object of the sub class is created $args = $resolver->resolve('alsoExpectsModel'); $result = alsoExpectsModel(...$args); assert($result instanceof SubModel); You can control the behavior of the function (in this case, alsoExpectsModel ) by annotating the parameter it with an Inject attribute. If the parameter is not annotated, the resolver would create an object of the base class Model because the type of the parameter $model is Model .","title":"Example"},{"location":"inject-attribute/#how-to-use","text":"Simply add the Inject attribute to a parameter of a callable or constructor that you want to control. You pass a mandatory argument with the value you want the callable's argument to have, or, if it's not a literal, with an identifier from which the value is derived ( see below for a detailed description ). The snippet below shows the relevant part of the example above: function alsoExpectsModel ( #[Inject ( SubModel :: class ) ] Model $model ): Model { ...","title":"How to use"},{"location":"inject-attribute/#the-inject-instance","text":"The first parameter $value of the Inject constructor is required and of type mixed. The second parameter $type is optional and of type Conia\\Wire\\Type which is a enum. Both are availabe as public instance properties. Every additional argument is avalable via the meta property. use Conia\\Wire\\Inject; use Conia\\Wire\\Type; $inject = new Inject('value', Type::Literal, text: 'string', number: 13); assert($inject->value === 'value'); assert($inject->type === Type::Literal); assert($inject->meta['text'] === 'string'); assert($inject->meta['number'] === 13); $inject = new Inject('value', text: 'string', number: 13); assert($inject->value === 'value'); assert($inject->type === null); assert($inject->meta['text'] === 'string'); assert($inject->meta['number'] === 13); $inject = new Inject('value', null, 31, 73, 'text'); assert($inject->value === 'value'); assert($inject->type === null); assert($inject->meta === [31, 73, 'text']); Note In most cases, you will only work directly with an Inject instance if you use the Inject type Type::Callback . See below .","title":"The Inject instance"},{"location":"inject-attribute/#how-injected-argument-values-are-determined","text":"The resolvers behave differently depending on the type of value that you want to be injected. Warning The resolver does not check if a value which was obtained with the help of an Inject attribute matches the parameters type of the callable it should be applied to, so handle with care.","title":"How injected argument values are determined"},{"location":"inject-attribute/#strings","text":"If the value is a string, like in the following example: #[Inject('container.id')] // or #[Inject(SubModel::class)] the resolver uses the following rules. If a container is available, see if it has an entry with and id matching the value of the string. If so, return it, if not continue with step 2. If the string is the full qualified name of an existing class, try to create it using the creator and return it. If not, continue with step 3. Return the string as-is.","title":"Strings"},{"location":"inject-attribute/#the-literal-rest","text":"All other types, like arrays, numbers, booleans or null values are passed to the callable or are returned by the resolver as they are, i. e. as unchanged literals. function withLiteralParams( #[Inject(['number' => 13, 'str' => 'value'])] array $arrayParam, #[Inject(73)] int $integerParam, #[Inject(13.37)] float $floatParam, #[Inject(true)] bool $booleanParam, #[Inject(null)] ?string $nullableParam, ) { ...","title":"The literal rest"},{"location":"inject-attribute/#dont-follow-the-rules","text":"If you want to bypass the string rules or be explicit about the values you inject, you can specifiy the type of the injected value. Additionally, with that feature, you can have control over how a value is generated. The inject type is passed as second argument to the Inject attribute und must be of the data type Conia\\Wire\\Type : // a valid array #[Inject('value', Conia\\Wire\\Type::Literal)] The available types are:","title":"Don't follow the rules"},{"location":"inject-attribute/#coniawiretypeliteral","text":"Returns the value as is. #[Inject('a string value', Type::Literal)] public function myCallable(string $value): void","title":"Conia\\Wire\\Type::Literal"},{"location":"inject-attribute/#coniawiretypeentry","text":"Uses the value as id to fetch a value from the container . $container->add('container.entry.id', new Object()); public function myCallable( #[Inject('container.entry.id', Type::Entry)] Object $value ): void $container->add(\\Your\\Interface::class, new Object()); public function myCallable( #[Inject(\\Your\\Interface::class, Type::Entry)] \\Your\\Interface $value ): void","title":"Conia\\Wire\\Type::Entry"},{"location":"inject-attribute/#coniawiretypecreate","text":"Must be a fully qualified class name which the creator attemtps to create. public function myCallable( #[Inject(SubModel::class, Type::Create)] Model $value ): void","title":"Conia\\Wire\\Type::Create"},{"location":"inject-attribute/#coniawiretypeenv","text":"The value is assumed to be the name an environment variable. It attempts to read the environment variable using PHP's internal function getenv and then returns its value. public function myCallable( #[Inject('PATH', Type::Env)] string|bool $value ): void { // $value has now the content of the environment variable PATH }","title":"Conia\\Wire\\Type::Env"},{"location":"inject-attribute/#coniawiretypecallback","text":"All resolving methods, like Creator::create or CallableResolver::resolve , accept a callback function for the parameter $injectCallback that will be passed all Inject attributes of type Type::Callback . The returned value of the callback is then used for the annotated parameter. use Conia\\Wire\\Inject; use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Type; use Conia\\Wire\\Wire; class Value { public function __construct(public readonly string $str) { } } class Model { public function __construct( #[Inject(Value::class, Type::Callback, tag: 'tag2')] public readonly Value $value ) { } } $container = new Container(); $container->add(Value::class . 'tag1', new Value('Tagged with 1')); $container->add(Value::class . 'tag2', new Value('Tagged with 2')); $creator = Wire::creator($container); $model = $creator->create( Model::class, injectCallback: function (Inject $inject) use ($container): mixed { return $container->get($inject->value . $inject->meta['tag']); } ); assert($model instanceof Model); assert($model->value->str === 'Tagged with 2');","title":"Conia\\Wire\\Type::Callback"},{"location":"license/","text":"MIT-License Copyright 2023-2024 ebene f\u00fcnf GmbH Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright 2023-2024 ebene f\u00fcnf GmbH Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT-License"},{"location":"resolvers/","text":"Argument Resolvers Wire provides two different autowiring argument resolvers, one for callables like functions, closures, etc and another for constructors . These resolvers are used internally by the creator. Resolve callable arguments To create an associative array of callable arguments, create a CallableResolver instance using the Wire factory and pass the callable to the resolve method. You can then pass the arguments to the callable via the ... operator, for example. Functions use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } function readValue(Value $value): string { return $value->str; } $resolver = Wire::callableResolver(); $args = $resolver->resolve('readValue'); assert(readValue(...$args) === 'value property'); Closures use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } $closure = function (Value $value): string { return $value->str; }; $resolver = Wire::callableResolver(); $args = $resolver->resolve($closure); assert($closure(...$args) === 'value property'); Instance methods use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public function readValue(Value $value): string { return $value->str; } } $model = new Model(); $resolver = Wire::callableResolver(); $args = $resolver->resolve([$model, 'readValue']); assert($model->readValue(...$args) === 'value property'); Static methods use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public static function readValue(Value $value): string { return $value->str; } } $resolver = Wire::callableResolver(); $args = $resolver->resolve([Model::class, 'readValue']); assert(Model::readValue(...$args) === 'value property'); Resolve constructor arguments You simply pass the fully qualified class name to the resolve method of the ConstructorResolver instance created by the Wire factory: use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public function __construct(public Value $value) { } } $resolver = Wire::constructorResolver(); $args = $resolver->resolve(Model::class); assert((new Model(...$args))->value->str === 'value property'); Factory methods If you have a class with a factory method you can use the callable resolver as shown in the static methods example. Assist resolvers with arguments that are already available If you have some of the necessary arguments already at hand, you can pass them converted to an associative array to the resolve method's predefinedArgs and/or predefinedTypes parameters. The array's keys must match the names or types of the parameters of the callable to be resolved. For more information, especially the difference between predefinedArgs and predefinedTypes , see Creator 's section about the same topic , which works in a similar way. An example using the callable resolver: use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public Value $value; public string $arg; public string $type; public static function create(string $arg, string $type, Value $value) { $model = new self(); $model->value = $value; $model->arg = $arg; $model->type = $type; return $model; } } $resolver = Wire::callableResolver(); $args = $resolver->resolve( [Model::class, 'create'], predefinedArgs: ['arg' => 'predefined argument'], predefinedTypes: ['string' => 'predefined type'], ); $model = Model::create(...$args); assert($model->value->str === 'value property'); assert($model->arg === 'predefined argument'); assert($model->type === 'predefined type'); The constructor resolver works the same way: use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public function __construct( public string $arg, public string $type, public Value $value ) { } } $resolver = Wire::constructorResolver(); $args = $resolver->resolve( Model::class, predefinedArgs: ['arg' => 'predefined argument'], predefinedTypes: ['string' => 'predefined type'] ); $model = new Model(...$args); assert($model->value->str === 'value property'); assert($model->arg === 'predefined argument'); assert($model->type === 'predefined type'); Using a PSR-11 container Like the creator, resolvers can be initialized with a container to help with unresolvable parameter arguments. (See also: PSR-11 Containers ) use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } class Model { public function __construct(protected Value $value) { } public function get(): string { return $this->value->get(); } } $container = new Container(); $container->add(Value::class, new Value('Model value')); $resolver = Wire::constructorResolver($container); $args = $resolver->resolve(Model::class); assert((new Model(...$args))->get() === 'Model value'); An example using the callable resolver: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } function readValue(Value $value): string { return $value->get(); } $container = new Container(); $container->add(Value::class, new Value('Model value')); $resolver = Wire::callableResolver($container); $args = $resolver->resolve('readValue'); assert(readValue(...$args) === 'Model value'); Creating the resolvers without the Wire factory Internally the Wire factory initializes the resolvers with the creator like shown here: use Conia\\Wire\\CallableResolver; use Conia\\Wire\\ConstructorResolver; use Conia\\Wire\\Creator; // A PSR-11 container implementation like // https://conia.dev/registry or https://php-di.org use Conia\\Wire\\Tests\\Fixtures\\Container; $container = new Container(); $creator = new Creator($container); $callableresolver = new CallableResolver($creator); $constructorResolver = new ConstructorResolver($creator); // Or without container $creator = new Creator(); $callableresolver = new CallableResolver($creator); $constructorResolver = new ConstructorResolver($creator);","title":"Argument Resolvers"},{"location":"resolvers/#argument-resolvers","text":"Wire provides two different autowiring argument resolvers, one for callables like functions, closures, etc and another for constructors . These resolvers are used internally by the creator.","title":"Argument Resolvers"},{"location":"resolvers/#resolve-callable-arguments","text":"To create an associative array of callable arguments, create a CallableResolver instance using the Wire factory and pass the callable to the resolve method. You can then pass the arguments to the callable via the ... operator, for example.","title":"Resolve callable arguments"},{"location":"resolvers/#functions","text":"use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } function readValue(Value $value): string { return $value->str; } $resolver = Wire::callableResolver(); $args = $resolver->resolve('readValue'); assert(readValue(...$args) === 'value property');","title":"Functions"},{"location":"resolvers/#closures","text":"use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } $closure = function (Value $value): string { return $value->str; }; $resolver = Wire::callableResolver(); $args = $resolver->resolve($closure); assert($closure(...$args) === 'value property');","title":"Closures"},{"location":"resolvers/#instance-methods","text":"use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public function readValue(Value $value): string { return $value->str; } } $model = new Model(); $resolver = Wire::callableResolver(); $args = $resolver->resolve([$model, 'readValue']); assert($model->readValue(...$args) === 'value property');","title":"Instance methods"},{"location":"resolvers/#static-methods","text":"use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public static function readValue(Value $value): string { return $value->str; } } $resolver = Wire::callableResolver(); $args = $resolver->resolve([Model::class, 'readValue']); assert(Model::readValue(...$args) === 'value property');","title":"Static methods"},{"location":"resolvers/#resolve-constructor-arguments","text":"You simply pass the fully qualified class name to the resolve method of the ConstructorResolver instance created by the Wire factory: use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public function __construct(public Value $value) { } } $resolver = Wire::constructorResolver(); $args = $resolver->resolve(Model::class); assert((new Model(...$args))->value->str === 'value property'); Factory methods If you have a class with a factory method you can use the callable resolver as shown in the static methods example.","title":"Resolve constructor arguments"},{"location":"resolvers/#assist-resolvers-with-arguments-that-are-already-available","text":"If you have some of the necessary arguments already at hand, you can pass them converted to an associative array to the resolve method's predefinedArgs and/or predefinedTypes parameters. The array's keys must match the names or types of the parameters of the callable to be resolved. For more information, especially the difference between predefinedArgs and predefinedTypes , see Creator 's section about the same topic , which works in a similar way. An example using the callable resolver: use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public Value $value; public string $arg; public string $type; public static function create(string $arg, string $type, Value $value) { $model = new self(); $model->value = $value; $model->arg = $arg; $model->type = $type; return $model; } } $resolver = Wire::callableResolver(); $args = $resolver->resolve( [Model::class, 'create'], predefinedArgs: ['arg' => 'predefined argument'], predefinedTypes: ['string' => 'predefined type'], ); $model = Model::create(...$args); assert($model->value->str === 'value property'); assert($model->arg === 'predefined argument'); assert($model->type === 'predefined type'); The constructor resolver works the same way: use Conia\\Wire\\Wire; class Value { public string $str = 'value property'; } class Model { public function __construct( public string $arg, public string $type, public Value $value ) { } } $resolver = Wire::constructorResolver(); $args = $resolver->resolve( Model::class, predefinedArgs: ['arg' => 'predefined argument'], predefinedTypes: ['string' => 'predefined type'] ); $model = new Model(...$args); assert($model->value->str === 'value property'); assert($model->arg === 'predefined argument'); assert($model->type === 'predefined type');","title":"Assist resolvers with arguments that are already available"},{"location":"resolvers/#using-a-psr-11-container","text":"Like the creator, resolvers can be initialized with a container to help with unresolvable parameter arguments. (See also: PSR-11 Containers ) use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } class Model { public function __construct(protected Value $value) { } public function get(): string { return $this->value->get(); } } $container = new Container(); $container->add(Value::class, new Value('Model value')); $resolver = Wire::constructorResolver($container); $args = $resolver->resolve(Model::class); assert((new Model(...$args))->get() === 'Model value'); An example using the callable resolver: use Conia\\Wire\\Tests\\Fixtures\\Container; use Conia\\Wire\\Wire; class Value { public function __construct(protected string $str) { } public function get(): string { return $this->str; } } function readValue(Value $value): string { return $value->get(); } $container = new Container(); $container->add(Value::class, new Value('Model value')); $resolver = Wire::callableResolver($container); $args = $resolver->resolve('readValue'); assert(readValue(...$args) === 'Model value');","title":"Using a PSR-11 container"},{"location":"resolvers/#creating-the-resolvers-without-the-wire-factory","text":"Internally the Wire factory initializes the resolvers with the creator like shown here: use Conia\\Wire\\CallableResolver; use Conia\\Wire\\ConstructorResolver; use Conia\\Wire\\Creator; // A PSR-11 container implementation like // https://conia.dev/registry or https://php-di.org use Conia\\Wire\\Tests\\Fixtures\\Container; $container = new Container(); $creator = new Creator($container); $callableresolver = new CallableResolver($creator); $constructorResolver = new ConstructorResolver($creator); // Or without container $creator = new Creator(); $callableresolver = new CallableResolver($creator); $constructorResolver = new ConstructorResolver($creator);","title":"Creating the resolvers without the Wire factory"}]}